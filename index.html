<!DOCTYPE html>
<html>

<head>
  
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
  <style>chart-container {
    width: 600px;
    height: 400px;
    position: relative;
}</style>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <meta http-equiv="X-UA-COmpatible" content="ie=edge" />

  <script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0/dist/Chart.bundle.min.js"></script>

  

  <title>Fetch txt : Job Shop</title>
</head>

<body>
  <!-- Choix de la composition  -->

  <label for="composition">Choissisez une composition : </label>
  <select class="w3-select w3-border" id="composition" name="composition">
    <option value="1">15 jobs 15 machines</option>
    <option value="2">20 jobs 15 machines</option>
    <option value="3">20 jobs 20 machines</option>
    <option value="4">30 jobs 15 machines</option>
    <option value="5">30 jobs 20 machines</option>
    <option value="6">50 jobs 15 machines</option>
    <option value="7">50 jobs 20 machines</option>
    <option value="8">100 jobs 20 machines</option>
  </select><br><br>

  <!-- Choix de l'instance -->

  <label for="composition">Choissisez une instance : </label>
  <select class="w3-select w3-border" id="instance" name="instance">
    <option value="1">1√®re instance</option>
    <option value="2">2√®me instance</option>
    <option value="3">3√®me instance</option>
    <option value="4">4√®me instance</option>
    <option value="5">5√®me instance</option>
    <option value="6">6√®me instance</option>
    <option value="7">7√®me instance</option>
    <option value="8">8√®me instance</option>
    <option value="9">9√®me instance</option>
    <option value="10">10√®me instance</option>
  </select><br><br>


  <!-- Boutton test -->

  <button class="w3-btn w3-teal" onclick="Cree_matrice_time()" id="bouton_matrice">Cr√©ation de la matrice time
    (lancement auto)</button>

  <button class="w3-btn w3-teal" onclick="Cree_matrice_machine()" id="bouton_matrice">Cr√©ation de la matrice machine
    (lancement auto)</button>
  <br>
  <button class="w3-btn w3-teal" onclick="Cree_vecteur_ordo(1)" id="bouton_vecteur_ordo">Cr√©ation de le vecteur
    ordonnancement (job 1)</button>

  <button class="w3-btn w3-teal" onclick="Cree_vecteur_time(1)" id="bouton_vecteur_time">Cr√©ation de le vecteur time
    (job 1)</button>

  <button class="w3-btn w3-teal" onclick="Cree_vecteur_debut(1)" id="bouton_vecteur_time">Cr√©ation de le vecteur debut
    (job 1)</button>


  <br>  <button class="w3-btn w3-teal" onclick="Cree_vecteur_ordo(2)" id="bouton_vecteur_ordo">Cr√©ation de le vecteur
    ordonnancement (job 2)</button>

  <button class="w3-btn w3-teal" onclick="Cree_vecteur_time(2)" id="bouton_vecteur_time">Cr√©ation de le vecteur time
    (job 2)</button>

  <button class="w3-btn w3-teal" onclick="Cree_vecteur_debut(2)" id="bouton_vecteur_time">Cr√©ation de le vecteur debut
    (job 2)</button>
  <br>


  <button class="w3-btn w3-teal" onclick="sortlabels(1)" id="bouton_vecteur_time">sortlabels()</button>

  <button class="w3-btn w3-teal" onclick="Cree_vecteur_gantt()" id="bouton_vecteur_time">Cree vecteur gantt()</button>

  <button class="w3-btn w3-teal" onclick="XZiter()" id="bouton_vecteur_time"> XZiter </button>

  <br><br>
  <button type="button" class="btn btn-info" onclick="chartIt()">Affichage du GANTT üòä</button>

  <div class="chart-container">
    <canvas id="chart"></canvas>
  </div>


  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/anton-shchyrov/chartjs-plugin-gantt/dist/chartjs-plugin-gantt.min.js"></script>

  <script>

    let nb_jobs = 0;
    let nb_machines = 0;
    let tables;
    let matrice_time = [];
    let matrice_machine = [];
    let vecteur_time = []; // depend de num_job
    let vecteur_ordo = []; // depend de num_job
    let vecteur_debut = [];
    let xlabels = [];
    let ylabels = [];
    let zlabels = []; // dur√©e
    let vecteur_gantt = []; // A utiliser -> Xlabels et Zlabels
    let Xlabels = [];
    let Zlabels = [];
    let debut_job_precedent = [];
    let s = 0;
    let vecteur_to = [];


    function deter_compo() { // d√©termination de la composition, ex : 1 -> [15,15] afin d'utiliser ces param√®tres dans les parcours de matrices
      if (composition.value == 1) { nb_jobs = 15; nb_machines = 15; }
      else if (composition.value == 2) { nb_jobs = 20; nb_machines = 15; }
      else if (composition.value == 3) { nb_jobs = 20; nb_machines = 20; }
      else if (composition.value == 4) { nb_jobs = 30; nb_machines = 15; }
      else if (composition.value == 5) { nb_jobs = 30; nb_machines = 20; }
      else if (composition.value == 6) { nb_jobs = 50; nb_machines = 15; }
      else if (composition.value == 7) { nb_jobs = 50; nb_machines = 20; }
      else if (composition.value == 8) { nb_jobs = 100; nb_machines = 20; }
      //console.log(nb_jobs); -------- debbug
      //console.log(nb_machines);
    }

    async function Cree_matrice_time() {
      matrice_time = [];
      deter_compo();

      const response = await fetch(composition.value + '.txt'); // Lecture du fichier s√©lectionn√©
      const data = await response.text();
      const tabless = data.split('\n').slice(3 + (4 * (instance.value - 1)) + (2 * nb_jobs * (instance.value - 1))); // 3 = start des lignes de des nombres

      let columns = tabless[1].split(' ').slice(1); // tabless 1 pour la ligne 2 pour debug les espaces / slice 1 pour saut√© l'espace en d√©but de ligne

      // trouvons les √©l√©ments (de mani√®re clean) avant de les mettres dans la matrice :)

      for (let step = 0; step < nb_jobs; step++) { // cr√©ation de la matrice_time

        let le_skip = tabless[step].split(' ')[1];

        if (le_skip == '') { // commencer le remplissage √† partir de slice(2)

          let step_s2 = 0;

          while (tabless[step].split(' ').slice(2)[step_s2] != undefined) {

            if (tabless[step].split(' ').slice(2)[step_s2] != '') { // √ßa esquive bien les ''

              matrice_time.push(tabless[step].split(' ').slice(2)[step_s2]);

            }

            step_s2 += 1;

          }
        }
        else { // remplissage √† partir de slice(1)

          let step_s1 = 0;

          while (tabless[step].split(' ').slice(1)[step_s1] != undefined) { // le remplissage de la ligne step

            if (tabless[step].split(' ').slice(1)[step_s1] != '') {

              matrice_time.push(tabless[step].split(' ').slice(1)[step_s1]);

            }

            step_s1 += 1;

          }
        }
      }

    }

    async function Cree_matrice_machine() {
      matrice_machine = [];
      deter_compo();

      const response = await fetch(composition.value + '.txt'); // Lecture du fichier s√©lectionn√©
      const data = await response.text();
      const tabless = data.split('\n').slice((4 + nb_jobs) + ((instance.value - 1) * (4 + 2 * nb_jobs))); // 3 = start des lignes de des nombres
      let columns = tabless[1].split(' ').slice(1); // tabless 1 pour la ligne 2 pour debug les espaces / slice 1 pour saut√© l'espace en d√©but de ligne
      // trouvons les √©l√©ments (de mani√®re clean) avant de les mettres dans la matrice :)

      for (let step = 0; step < nb_jobs; step++) { // cr√©ation de la matrice_machine

        let le_skip = tabless[step].split(' ')[1];

        if (le_skip == '') { // commencer le remplissage √† partir de slice(2)

          let step_s2 = 0;

          while (tabless[step].split(' ').slice(2)[step_s2] != undefined) {

            if (tabless[step].split(' ').slice(2)[step_s2] != '') { // √ßa esquive bien les ''

              matrice_machine.push(tabless[step].split(' ').slice(2)[step_s2]);

            }

            step_s2 += 1;

          }
        }
        else { // remplissage √† partir de slice(1)

          let step_s1 = 0;

          while (tabless[step].split(' ').slice(1)[step_s1] != undefined) { // le remplissage de la ligne step

            if (tabless[step].split(' ').slice(1)[step_s1] != '') {

              matrice_machine.push(tabless[step].split(' ').slice(1)[step_s1]);

            }

            step_s1 += 1;

          }
        }
      }

    }

    function Cree_vecteur_ordo(num_job) { // initialise puis push dans vecteur_ordo l'ordonnancement des machines du job "num_job" <- param√®tre d'entr√©

      vecteur_ordo = [];

      for (let step = 0; step < nb_machines; step++) { // parcours des lignes du job dans la matrice :)

        vecteur_ordo.push(parseInt(matrice_machine[((num_job - 1) * nb_machines) + step]));

      }

      //console.log('vecteur ord = ' + vecteur_ordo);

      return vecteur_ordo;

    }

    function Cree_vecteur_time(num_job) { // initialise puis push dans vecteur_time le temps des machines du job "num_job" <- param√®tre d'entr√©

      vecteur_time = [];

      for (let step = 0; step < nb_machines; step++) { // parcours des lignes du job dans la matrice :)

        vecteur_time.push(parseInt(matrice_time[((num_job - 1) * nb_machines) + step]));

      }

      //console.log(ordo);

      return vecteur_time;

    }

    function Cree_vecteur_debut(num_job) { // min ~ ope(n+1) d√©bute apr√®s op√©(n)  // vecteur des d√©buts // le i c'est num_job
      vecteur_debut = [];

      //if (i == 1) {

      for (let step = 0; step < nb_machines; step++) {
        vecteur_debut.push(parseInt(s));
        s = (parseInt(s) + parseInt(vecteur_time[step]));
      }

      return vecteur_debut;

    }


    async function sortlabels(num_job) {
      let indicemax = 0;
      let max = 0;
      let intermediaire_x;
      let intermediaire_z
      xlabels = vecteur_debut;
      ylabels = vecteur_ordo;
      zlabels = vecteur_time;

      for (let k = 0; k < xlabels.length; k++) {
        max = 0;
        for (let step = k; step < xlabels.length; step++) {

          if (max < parseInt(ylabels[step])) {
            max = ylabels[step];
            intermediaire_x = xlabels[step];
            intermediaire_z = zlabels[step];
            indicemax = step;
          }
        }
        ylabels[indicemax] = ylabels[k];
        ylabels[k] = max;

        xlabels[indicemax] = xlabels[k];
        xlabels[k] = intermediaire_x;

        zlabels[indicemax] = zlabels[k];
        zlabels[k] = intermediaire_z;

      }
      return { xlabels, ylabels, zlabels }
    }

    function XZiter() {

      for (let i = 1; i < nb_jobs + 1; i++) {

        Cree_vecteur_time(i);

        Cree_vecteur_ordo(i);

        Cree_vecteur_debut(i);

        sortlabels(i);

        Cree_vecteur_gantt();

      }
    }



    function Cree_vecteur_gantt() {
      let couleur_random = (Math.random() * 0xFFFFFF << 0).toString(16);
      vecteur_to = [];

      for (let step = 0; step < xlabels.length; step++) {

        vecteur_to.push(parseInt(xlabels[step]) + parseInt(zlabels[step]));

      }
      // LA C BON -> vecteur_gantt.push({ x: {from: xlabels[0], to: vecteur_to[0]}, y: ylabels[0], backgroundColor: '#' + (Math.random() * 0xFFFFFF << 0).toString(16)})
      for (let k = 0; k < xlabels.length; k++) {

        vecteur_gantt.push({ x: {from: xlabels[k], to: vecteur_to[k]}, y: ylabels[k], backgroundColor: '#' + couleur_random})

      }
    }

    async function chartIt() {
      /////////------------------------------------------------------------------


      const chart = new Chart("chart", {
        type: 'gantt',
        data: {
          datasets: [{
            height: 1,  // default 5
            width: 1,  // default 5
            label: "Size sample",
            data: vecteur_gantt
        }]
        },
      });
    }

    Cree_matrice_time();
    Cree_matrice_machine();

  </script>

</body>

</html>
